"""{{ description }}"""
{% if lazy_imports %}
# Lazy imports for performance - modules are loaded on first access
from __future__ import annotations

import sys
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    # Type checking needs to see all exports
    {% for import_line in imports %}
    {{ import_line }}
    {% endfor %}

__all__ = [
{% for name in exports %}
    "{{ name }}",
{% endfor %}
]

# Mapping of symbol names to their import paths
_IMPORT_MAP: dict[str, tuple[str, str]] = {
    {% for name, module_path, module_name in lazy_import_map %}
    "{{ name }}": ("{{ module_path }}", "{{ module_name }}"),
    {% endfor %}
}

# Track which models need rebuilding after import
_MODELS_TO_REBUILD = {
    {% for model_info in rebuild_models %}
    {% if model_info.is_model %}
    "{{ model_info.name }}",
    {% endif %}
    {% endfor %}
}

# Track what's been imported and whether all models have been rebuilt
_imported: set[str] = set()
_all_models_rebuilt = False


def _rebuild_all_models() -> None:
    """Import and rebuild all models when first model is accessed.

    This also imports all enums to ensure they're available for model references.
    """
    global _all_models_rebuilt
    if _all_models_rebuilt:
        return

    # Import all symbols (enums and models) first
    for name in _IMPORT_MAP:
        if name not in _imported:
            module_path, module_name = _IMPORT_MAP[name]
            module = __import__(module_path, fromlist=[module_name])
            symbol = getattr(module, module_name)
            globals()[name] = symbol
            _imported.add(name)

    # Now rebuild all models with complete namespace
    _globals = sys.modules[__name__].__dict__
    for model_name in _MODELS_TO_REBUILD:
        globals()[model_name].model_rebuild(_types_namespace=_globals)

    _all_models_rebuilt = True


def __getattr__(name: str) -> Any:
    """Lazy import symbols on first access."""
    if name not in _IMPORT_MAP:
        raise AttributeError(f"module {__name__!r} has no attribute {name!r}")

    # Check if already imported
    if name in _imported:
        return globals()[name]

    # If this is a model and models haven't been rebuilt yet, do batch rebuild
    if name in _MODELS_TO_REBUILD and not _all_models_rebuilt:
        _rebuild_all_models()
        return globals()[name]

    # Import non-model symbols (enums) normally
    module_path, module_name = _IMPORT_MAP[name]
    module = __import__(module_path, fromlist=[module_name])
    symbol = getattr(module, module_name)

    # Cache in module globals
    globals()[name] = symbol
    _imported.add(name)

    return symbol


def __dir__() -> list[str]:
    """Support for dir() and autocomplete."""
    return sorted(__all__)
{% else %}
{% for import_line in imports %}
{{ import_line }}
{% endfor %}

__all__ = [
{% for name in exports %}
    "{{ name }}",
{% endfor %}
]
{% if rebuild_models %}


# Rebuild models to resolve forward references
def _rebuild_models() -> None:
    """Rebuild all models to resolve forward references after all imports are complete."""
    import sys
    # Pass the current module's globals so Pydantic can find all imported types
    _globals = sys.modules[__name__].__dict__
    {% for model_info in rebuild_models %}
    {% if model_info.is_model %}
    {{ model_info.name }}.model_rebuild(_types_namespace=_globals)
    {% endif %}
    {% endfor %}


# Only rebuild if this is the first import (not during circular imports)
if __name__ != "__main__":
    _rebuild_models()
{% endif %}
{% endif %}
